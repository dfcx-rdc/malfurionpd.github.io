+++

title = "Rust编程之道读书笔记"
description = "Rust编程之道读书笔记"
author = "adeng"
tags = [
    "rust",
    "notes",
]
date = "2021-05-31"
categories = [
    "Rust", "notes"
]

image = "WX20210420-201336@2x.png"



+++





# 第一章 <br><br>新时代的语言



 <font face="华文楷体">不谋全局者，不足谋一域。</font>

<p align="right"><font face="华文楷体">不谋全局者，不足谋一域。</font></p>

<br>

为了达成目标， Rust语言遵循了三条设计哲学:

*内存安全

*零成本 抽象

*实用性



像 CIC++语言的类型系统 就不是类型安全的，因为它 们并没有对 无意义 的行为进行 约束。一个最简单 的例子就 是数组 越界，在 CIC++语言中并不对其做任何检查，导致发生了语 言规范规定之外的行为，也就是 未定义行为 (Undefined Behavior)。 



C++中的RAII机制 Resource Acquisition Is Initialization

LLVM https://www.jianshu.com/p/1367dad95445



在进一步学习之前，我们有必要了解一下 Rust代码是如何执行的。 Rust是跨平台语言， 一次编译，到处运行，这得益于 LLVM。 Rust编译器是一个 LLVM 编译前端，它将代码编译 为 LLVMIR， 然后经过 LLVM 编译为相应的平台目标 。

Rust 源码经过分词和解析，生成 AST C抽象语法树)。 然后把 AST 进一步简化处理为 HIR CHigh-level IR)，目的是让编译器更方便地做类型检 查。 HIR 会进一步被编译为 MIR (MiddleIR)，这是一种中间表示，它在 Rustl.12版本中被引入， 主要用于以下目的。

.缩短编译时间 。 MIR 可以帮助实现增量编译，当你修改完代码重新编译的时候 ， 编译 器只 计 算更改过的部分，从而缩短了编译时间 。

·缩短执行时间 。 MIR 可以 在 LLVM 编 译之前实现更细粒度的优 化，因为 单纯依赖 LLVM 的优化粒度太粗，而且 Rust无法控制，引入 MIR就增加了更多的优化空间。

.更精确的类型检查 。 MIR 将帮助实现更灵活的借用检查，从而可以提升 Rust 的使用 体验 。

最终， MIR 会被翻译为 LLVM IR， 然后被 LLVM 的处理编译为能在各个平台上运行的 目标机器码 。



# 第二章 语言精要

Rust 中 的语法可以分成两大类 :语句 (Statement) 和表达式 (Expression)。语句是指

要执行的一些操作和产生副作用的表达式。表达式主要用于计算求值。
 i吾句又分为两种: 声明语句 ( Declaration statement )和 表达式语句 ( Expression

· 声明语句，用于声明各种语言项 Cltem)，包括声明变量、静态变量、常量、 结构体、 函数等，以及通过 extern 和 use 关键字引入包和模块等。

· 表达式语句，特指以分号结尾的表达式。此类表达式求值结果将会被舍弃 ， 并总是返 回单元类型() 。



> 不是很清楚···





函数体的花括号识别为块表达式( Block Expression)

块中的最后一个表达式是宏语句，所以返回单元 值()。



## 2.3 变量与绑定

通过 let关键字来创建变量，这是 Rust语言从函数式语言中借鉴的语法形式。 let创建的 变量 一 般称为 绑定 (Binding)，它表明了标识符( Identifier) 和|值( Value)之 间 建立 的 一 种 关联关系。



Rust 中 的表达式一般可以分为 位置表达式 (Place Expression )和 值表达式 (Value Expression)。在其他语言中， 一般 叫作 左值 CLValue)和右值( RValue)。



从语义角度来说，位置表达式代表了持久性数据，值表达式代表了临时数据 。位置表达 式一般有持久的状态，值表达式要么是字面量，要么是表达式求值过程中创建的临时值。

表达式的求值过程在不同的上下文中会有不同的结果。求值上下文也分为 位置上下文 (Place Context)和值上下文 (Value Context)。下面几种表达式属于位置上下文:

·赋值或者复合赋值语句左侧的操作数 。
 · 一元 引用表达式的独立操作数 。
 ·包含隐式借用(引用)的操作数 。
 • match 判别式或 let 绑定右侧在使用 ref模式匹配的时 候也是位置上下文。

除了上述几种情况，其余表达式都属于值上下文 。值表达式不能 出现在位置上下文中， 如代码清单 2-3 所示 。



> 还没什么概念，待验证···



## 2.4 函数与闭包

Rust 语言的作用域是静态作用 i茧，即词法作用域( Lexical Scope)。 由一对花括号来开 辟作用域， 其作用域在词法分析阶段就巳经确定了 ， 不会动态改变。 



在 Rust中，函数为一等公民。这意味着，函数自身就可以作为函数的参数和返回值使用。

注意这里直接使用函数的名字来作为函数指针 。



Rust编译器也可以像 C++或D语言那样，拥有编译时函数执行(Compile-TimeFunction Execution, CTFE)的能力 。 

除了 const fn， 官方还在实现 const generics 特性 。



闭包也叫匿名函数 。 闭包有以下几个特点 :

.可以像函数 一样被调用 。
 ·可以捕 获上下文环境中的自由变 量。 .可以自 动推断输入和返回的类型 。



闭包也可以作为函数参数和返回值， 但使用起来略有区别。

Rust中闭包实际上就是由一个匿名结构体和 trait来组合实现的。

闭包同样也可以作为返回值

在代码清单 2-15 中使用了 imp! Fn(i32) -> i32 作为函数的返回值，它表示实现 Fn(i32) -> 的类型。



## 2.5 流程控制

在 Rust 语言中， match 分支左边就是模式，右边就是执行代码 。 模式匹配同时也是一个 表达式，和 if表达式类似，所有分支必须返回同一个类型。



## 2.6 基本数据类型



## 2.10 泛型和trait

代码第 25行和第 26行通过 fly_static::<Duck>(duck)调用了 Duck实现的的 方法， 并返回 tmeo

上面这种调用方式在 Rust 中 叫静态分发 。 Rust 编译器会为 何一static::<Pig>(pig)和 fly_static: :<Duck>(duck)这两个具体类型的调用生成特殊化的代码。 也就是说，对于 编译器来 说，这种 抽 象并不存在，因为在编译阶段，泛型己经被展开为具体类 型的代码 。

代码第 27 行和第 28 行分别调用了 fly_dyn(&Pig)和 fly dyn(&Duck)，也可以 实现同样的 效果。但是 fly dyn 函数是动态分发方式的， 它会在运行时查找相应类型的方法， 会带来一 定的运行 时开销， 不过这种开销很小。









# Thought

全书内容都是MD格式可以覆盖的！

